//Variabler til x og y aksen for gradient baggrund
int Y = 1;
int X = 2;

//Variabler til farverne i gradient baggrund
color b1, b2;

//Variabler til 3D terrain
int kollonne, raekke;
int skalar = 40;
int bredde = width;
int hoejde = height + 40;
float[][] terrain;
float fly = 0;


void setup() {
  
  noStroke();  
  fullScreen(P3D);

  //Definere variablerne til 3D terrain
  bredde = width;
  hoejde = height;
  kollonne = bredde / skalar;
  raekke = hoejde / skalar + 20;
  terrain = new float [kollonne] [raekke];
 
  
  //Definere farverne til gradient baggrunden
  b1 = color(0, 0, 51);
  b2 = color(75, 0, 77);

}

void draw() {
  
 
  //Kalder p책 gradients void
  gradientBack(0, 0, width, height, b1, b2, Y);

  //Viser 3D terrain p책 vores canvas
  terrainDisplay();
 
  //Viser sun p책 canvas
  bigSun();

  
}

void bigSun() {
 stroke(224,93,93);
 strokeWeight(250);
 ellipse(width / 2, height / 2 + 60, 240, 240); 
 strokeWeight(1);
 
}

//Custom void til gradient p책 baggrunden
void gradientBack(int x, int y, float w, float h, color b1, color b2, int axis) {
  
  
  if (axis == Y) {
    for (int i = y; i <= y + h; i++){
      float inter = map(i, y, y + h, 0, 1);
      color c = lerpColor(b1, b2, inter);
      stroke(c);
      line(x, i, x + w, i);
    }
  }
  else if (axis == X) {
    for (int i = x; i <= x + w; i++) {
      float inter = map(i, x, x + w, 0, 1);
      color c = lerpColor(b1, b2, inter);
      stroke(c);
      line(i, y, i, y + h);
      
    }
  }
}

//Custom void til 3D terrain generation
void terrainDisplay() {
  
  fly -= 0.009; 
  
  float yOff = fly;
  for(int y = 0; y < raekke; y++) {
    float xOff = 0;
    for(int x = 0; x < kollonne; x++) {
      terrain[x][y] = map(noise(xOff,yOff), 0, 1, -140, 140);
      xOff += 0.21;
    }
    yOff += 0.21;
  }
  
      
  stroke(0, 205, 205);
  strokeWeight(2);
  fill(30);
  push(); 
  translate(width / 2, height / 2 + 150);
  rotateX(PI / 2);
  translate(-bredde / 2, -hoejde / 2);
  
  for(int y = 0; y < raekke - 1; y++) {
    beginShape(TRIANGLE_STRIP);
    for(int x = 0; x < kollonne; x++) {
      vertex(x * skalar, y * skalar, terrain [x] [y]);
      vertex(x * skalar, (y+1) * skalar, terrain [x] [y + 1]);
      
    }
    endShape();
  }
  pop();
}

